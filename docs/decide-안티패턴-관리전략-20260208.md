# 언어별/프레임워크별 안티패턴 관리 전략 판단 결과

> 판단일: 2026-02-08

## 결정 요약

**권고**: **후보 D(하이브리드)** - `.claude/rules/` 디렉토리에 언어별 안티패턴 규칙 파일을 분리 관리 + hooks로 핵심 안티패턴을 실시간 차단 + 구현 시점에 Context7 실시간 조회 병행
**확신도**: 높음 - Claude Code의 공식 아키텍처가 이 접근법을 직접 지원하며, 실무 사례에서도 검증됨

## 후보 분석

### 후보 A: 별도 안티패턴 지식베이스 구축

`.claude/knowledge/antipatterns/` 같은 디렉토리에 언어/프레임워크별 안티패턴 파일을 체계적으로 관리하는 방식.

- **장점**:
  - 체계적인 분류와 검색 가능
  - 팀 공유 및 버전 관리 용이 (git으로 추적)
  - 프로젝트 특화 안티패턴 축적 가능
  - 오프라인에서도 활용 가능
- **단점**:
  - 유지보수 부담이 큼 (언어/프레임워크 업데이트마다 갱신 필요)
  - 컨텍스트 토큰을 크게 소비할 위험 (Claude Code 공식 가이드: "Context tokens are precious")
  - 정보가 금방 구식이 됨 (안티패턴은 언어 버전에 따라 변화)
  - Claude가 이미 알고 있는 일반적 안티패턴까지 중복 기술하게 됨
- **적합한 경우**: 인터넷 접근이 제한된 환경, 극도로 특수한 도메인

### 후보 B: implement 스킬 내 인라인 관리

SKILL.md 안에 주요 안티패턴 규칙을 직접 포함하는 방식.

- **장점**:
  - 단일 파일 관리로 단순함
  - 구현 시 자동으로 컨텍스트에 로드됨
  - 추가 설정 불필요
- **단점**:
  - SKILL.md가 비대해져 핵심 프로세스 지시가 묻힘
  - 모든 언어의 안티패턴이 한 파일에 → 불필요한 컨텍스트 소비
  - Claude Code 공식 가이드가 경고: "Bloated CLAUDE.md files cause Claude to ignore your actual instructions" (SKILL.md에도 동일 적용)
  - 언어별 선별 로딩 불가
- **적합한 경우**: 단일 언어 프로젝트에서 안티패턴이 5개 이하로 적은 경우

### 후보 C: 외부 도구/린터에 완전 위임

ESLint, Pylint, Clippy 등 정적 분석 도구에 안티패턴 검출을 전적으로 맡기는 방식.

- **장점**:
  - 결정적(deterministic) 검출 - 누락 없음
  - CI/CD 파이프라인 통합 용이
  - 커뮤니티 규칙을 바로 활용 가능
  - Claude의 컨텍스트 소비 제로
- **단점**:
  - 구조적/아키텍처 수준의 안티패턴은 감지 불가 (God Object, 과도한 상속 등)
  - 언어별 린터를 각각 설정해야 하는 복잡성
  - "문맥 인식" 부족 - 코드의 의도를 파악하지 못함
  - 새로운 안티패턴에 대한 규칙 추가가 느림
- **적합한 경우**: 이미 잘 설정된 린터가 있는 성숙한 프로젝트

### 후보 D: 하이브리드 (rules 파일 + hooks + 실시간 조회)

Claude Code의 공식 기능을 조합하는 방식:
1. `.claude/rules/antipatterns-{lang}.md` - 언어별 규칙 파일 (자동 로드)
2. `.claude/settings.json` hooks - 핵심 안티패턴 실시간 차단
3. Context7/WebSearch - 구현 시점에 최신 안티패턴 조회

- **장점**:
  - Claude Code 아키텍처에 최적화됨 (rules 디렉토리는 자동 로드, 스킬은 온디맨드)
  - 계층별 역할 분리: hooks(차단) → rules(지침) → 실시간 조회(최신성)
  - 컨텍스트 효율적 - rules 파일은 짧게 유지하고, 상세 내용은 필요시 조회
  - 프로젝트 특화 안티패턴과 범용 안티패턴을 모두 커버
  - 기존 implement 스킬의 린트 실행 단계와 자연스럽게 연동
- **단점**:
  - 초기 설정에 시간이 더 소요됨
  - 여러 메커니즘을 이해하고 관리해야 함
  - 인터넷 접근 불가 시 실시간 조회 부분 누락
- **적합한 경우**: 다중 언어 프로젝트, 지속적으로 진화하는 코드베이스

## 평가 매트릭스

| 기준 | A: 지식베이스 | B: 인라인 | C: 린터 위임 | D: 하이브리드 |
|------|:---:|:---:|:---:|:---:|
| **유지보수 부담** | 높음 | 중간 | 낮음 | 중간 |
| **정보 최신성** | 낮음 | 낮음 | 중간 | 높음 |
| **컨텍스트 효율** | 낮음 | 낮음 | 높음 | 높음 |
| **실제 활용도** | 중간 | 낮음 | 중간 | 높음 |
| **구현 복잡도** | 중간 | 낮음 | 중간 | 중간 |
| **확장성** | 중간 | 낮음 | 높음 | 높음 |
| **아키텍처 정합성** | 낮음 | 낮음 | 중간 | 높음 |
| **종합** | C | D | B | A |

## 트레이드오프

- **후보 A(지식베이스)를 선택하면** 체계적 분류를 얻지만 유지보수 부담과 컨텍스트 낭비를 감수해야 한다. Claude는 이미 대부분의 범용 안티패턴을 알고 있으므로 중복이 발생한다.
- **후보 B(인라인)를 선택하면** 단순성을 얻지만 SKILL.md가 비대해져 핵심 지시가 묻히는 위험을 감수해야 한다.
- **후보 C(린터 위임)를 선택하면** 결정적 검출과 컨텍스트 절약을 얻지만 구조적 안티패턴과 문맥 의존적 안티패턴을 놓친다.
- **후보 D(하이브리드)를 선택하면** 포괄적 커버리지와 최신성을 얻지만 초기 설정 비용과 다중 메커니즘 관리 부담을 감수해야 한다.

## 최종 권고

### 1차 권고: 후보 D(하이브리드) 채택

구체적 구현 방안:

#### 1단계: `.claude/rules/` 디렉토리에 언어별 규칙 파일 생성

```
.claude/rules/
├── antipatterns-python.md    # Python 프로젝트에서 자동 로드
├── antipatterns-typescript.md
├── antipatterns-rust.md
└── antipatterns-general.md   # 범용 (God Object, 순환 의존 등)
```

각 파일은 **프로젝트에서 실제로 반복되는 안티패턴만** 짧게 기술한다 (10~20줄 이내). Claude가 이미 아는 범용 안티패턴(예: SQL Injection)은 기술하지 않는다. CLAUDE.md 공식 가이드의 원칙을 따름: "Would removing this cause Claude to make mistakes? If not, cut it."

#### 2단계: hooks로 핵심 안티패턴 실시간 차단

```json
// .claude/settings.json 예시
{
  "hooks": {
    "PostToolUse": [
      {
        "matcher": "Edit|Write",
        "command": "check-antipatterns.sh"
      }
    ]
  }
}
```

hooks는 정규식 기반이므로 패턴이 명확한 안티패턴(예: `as any`, `eval()`, `console.log` 등)만 차단한다.

#### 3단계: implement 스킬에 조회 단계 추가

implement 스킬의 "3. 코드 작성" 전에, 해당 언어/프레임워크의 최신 안티패턴을 Context7 또는 WebSearch로 간략히 확인하는 단계를 추가한다. 이는 rules 파일로 커버하지 못하는 최신 안티패턴을 보완한다.

### 조건부 권고

- **단일 언어 소규모 프로젝트**: 후보 D의 1단계(rules 파일)만으로 충분. hooks와 실시간 조회는 생략 가능.
- **이미 잘 갖춰진 린터 파이프라인이 있는 프로젝트**: 후보 C + 후보 D의 1단계 조합이 최적. 린터가 못 잡는 구조적 안티패턴만 rules 파일로 보완.
- **인터넷 접근 불가 환경**: 후보 A + 후보 D의 2단계 조합. 지식베이스를 좀 더 상세하게 구축하되 hooks로 보강.

## 출처

- [Best Practices for Claude Code - 공식 문서](https://code.claude.com/docs/en/best-practices)
- [Optimizing Claude Code: Skills, Plugins, and the Art of Teaching Your AI to Code Like You](https://mays.co/optimizing-claude-code)
- [The Complete Guide to CLAUDE.md](https://www.builder.io/blog/claude-md-guide)
- [AI Code Review vs Static Analysis](https://graphite.com/guides/ai-code-review-vs-static-analysis)
- [Claude Code 2026: Practical End-to-End SDLC Workflow](https://developersvoice.com/blog/ai/claude_code_2026_end_to_end_sdlc/)
- [Building Guardrails for AI Coding Assistants: A PreToolUse Hook System](https://dev.to/mikelane/building-guardrails-for-ai-coding-assistants-a-pretooluse-hook-system-for-claude-code-ilj)
- [claude-code-guardrails - GitHub](https://github.com/rulebricks/claude-code-guardrails)
- [Antipatterns Overview - DevIQ](https://deviq.com/antipatterns/antipatterns-overview/)
- [Design Patterns and Refactoring - SourceMaking](https://sourcemaking.com/antipatterns/software-development-antipatterns)
